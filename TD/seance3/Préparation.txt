1. Code pour mesurer le temps d'exécution

<?php
$debut = microtime(true);
$fin = microtime(true);
$dureeExecution = $fin - $debut;
?>

2. Intérêt d'index :

Les index sont utilisés pour rechercher rapidement des lignes avec des valeurs de
colonne spécifiques. Sans index, MySQL doit commencer par la première ligne, puis
parcourir toute la table pour trouver les lignes pertinentes.Si la table a un index pour
les colonnes en question, MySQL peut rapidement déterminer la position sans avoir à
regarder toutes les données. C'est donc beaucoup plus rapide.

Principe de fonctionnement :

- Pour trouver rapidement les lignes correspondant à une clause WHERE.
- Pour éliminer les lignes de la considération. S'il y a un choix entre plusieurs index, MySQL
  utilise normalement l'index qui trouve le plus petit nombre de lignes.
- Par exemple, si vous avez un index à trois colonnes sur (col1, col2, col3), vous avez
  indexé les capacités de recherche sur (col1), (col1, col2) et (col1, col2, col3).
- Pour récupérer des lignes à partir d'autres tables lors de l'exécution de jointures.
  MySQL peut utiliser les index des colonnes plus efficacement s'ils sont déclarés de même type
  et de même taille. Dans ce contexte, VARCHAR et CHAR sont considérés comme identiques s'ils sont
  déclarés comme ayant la même taille. Par exemple, VARCHAR (10) et CHAR (10) ont la même taille,
  mais VARCHAR (10) et CHAR (15) ne le sont pas.
- Pour les comparaisons entre les colonnes de chaînes non binaires, les deux colonnes doivent
  utiliser le même jeu de caractères.
- La comparaison de colonnes différentes peut empêcher l'utilisation d'index si les valeurs ne
  peuvent pas être comparées directement sans conversion. Pour une valeur donnée telle que 1 dans la
  colonne numérique, il peut être égal à n'importe quel nombre de valeurs dans la colonne chaîne comme
  «1», «1», «00001» ou «01 .e1». Cela exclut l'utilisation de tout index pour la colonne de chaîne.
- Pour trouver la valeur MIN () ou MAX () pour une colonne indexée spécifique key_col. Ceci est
  optimisé par un préprocesseur qui vérifie si vous utilisez WHERE key_part_N = constant sur toutes les
  parties clés qui se produisent avant key_col dans l'index. Dans ce cas, MySQL effectue une recherche
  de clé unique pour chaque expression MIN () ou MAX () et la remplace par une constante. Si toutes les
  expressions sont remplacées par des constantes, la requête retourne immédiatement.

Partie 2 : observer l'orm, améliorer les performances avec des chargements liés

1. Structure du log de requêtes dans Eloquent



2. Le problème des N+1 query

Le problème est que chaque requête a un peu de surcharge. Il est beaucoup plus rapide d'émettre 1 requête
qui renvoie 100 résultats que d'émettre 100 requêtes qui renvoient chacune 1 résultat. Cela est
 particulièrement vrai si votre base de données se trouve sur une machine différente qui est, disons, à 1-2
 ms du réseau. Dans ce cas, l'émission de 100 requêtes en série a un coût minimum de 100-200 ms, même si MySQL
 peut les satisfaire instantanément.
